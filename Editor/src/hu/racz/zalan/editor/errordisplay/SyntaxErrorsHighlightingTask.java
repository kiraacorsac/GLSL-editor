package hu.racz.zalan.editor.errordisplay;

import hu.racz.zalan.editor.core.*;
import hu.racz.zalan.editor.core.scope.*;
import java.util.*;
import javax.swing.text.*;
import org.netbeans.modules.parsing.spi.*;
import org.netbeans.spi.editor.hints.*;
import org.openide.util.*;

public class SyntaxErrorsHighlightingTask extends ParserResultTask<GlslParser.GlslEditorParserResult> {

    private Document document;

    public SyntaxErrorsHighlightingTask() {
    }

    @Override
    public void run(GlslParser.GlslEditorParserResult result, SchedulerEvent event) {
        try {
            initialize(result);
            addErrorsToNetbeansEditor(result);
        } catch (ParseException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    private void initialize(GlslParser.GlslEditorParserResult result) throws ParseException {
        document = result.getSnapshot().getSource().getDocument(false);
    }

    private void addErrorsToNetbeansEditor(GlslParser.GlslEditorParserResult result) throws ParseException {
        List<SyntaxError> antlrGeneratedErrors = GlslProcessor.getAutoGeneratedErrors();
        List<ErrorDescription> errors = new ArrayList<>();
        for (SyntaxError error : antlrGeneratedErrors) {
            ErrorDescription errorDescription = transformAntlrErrorToNetbeansError(error);
            errors.add(errorDescription);
        }

        Scope rootScope = GlslProcessor.getRootScope();

        for (int i = 0; i < rootScope.getFunctionDefinitionCount(); i++) {
            Function def = rootScope.getFunctionDefinition(i);
            boolean valid = false;
            boolean valid2 = true;
            if (def.getName().equals("main") && def.getParameterCount() == 0 && def.getReturnType().equals("void")) {
                valid = true;
            }
            for (int j = 0; j < rootScope.getFunctionPrototypeCount(); j++) {
                Function prot = rootScope.getFunctionPrototype(j);
                if (prot.equals(def) && prot.getStopIndex() < def.getStartIndex()) {
                    valid = true;
                }
            }
            for (int j = 0; j < rootScope.getFunctionDefinitionCount(); j++) {
                Function def2 = rootScope.getFunctionDefinition(j);
                if (def != def2 && def.equalsSignature(def2) && def.getStopIndex() > def2.getStartIndex()) {
                    valid2 = false;
                }
            }
            if (!valid) {
                List<Fix> fixes = new ArrayList<>();
                fixes.add(new CreateFunctionPrototype(def));
                ErrorDescription ed = ErrorDescriptionFactory.createErrorDescription(Severity.WARNING, def.getName() + " function's prototype not exists", fixes, document, new MyPosition(def.getStartIndex()), new MyPosition(def.getSignatureStopIndex()));
                errors.add(ed);
            }
            if (!valid2) {
                List<Fix> fixes = new ArrayList<>();
                fixes.add(new MyFix(def.getStartIndex(), def.getStopIndex()));
                ErrorDescription ed = ErrorDescriptionFactory.createErrorDescription(Severity.ERROR, "'" + def.getName() + "' function already has a body", fixes, document, new MyPosition(def.getStartIndex()), new MyPosition(def.getSignatureStopIndex()));
                errors.add(ed);
            }
        }

        HintsController.setErrors(document, "GLSL", errors);
    }

    public class MyPosition implements Position {

        private final int position;

        public MyPosition(int pos) {
            position = pos;
        }

        @Override
        public int getOffset() {
            return position;
        }

    }

    public class CreateFunctionPrototype implements Fix {

        private final Function functionDefinition;

        public CreateFunctionPrototype(Function func) {
            this.functionDefinition = func;
        }

        @Override
        public String getText() {
            return "Create prototype";
        }

        @Override
        public ChangeInfo implement() throws Exception {
            document.insertString(functionDefinition.getStartIndex(), functionDefinition + ";\n\n", null);
            return null;
        }

    }

    public class MyFix implements Fix {

        int start;
        int end;

        public MyFix(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        public String getText() {
            return "Remove this function";
        }

        @Override
        public ChangeInfo implement() throws Exception {
            document.remove(start, end - start);
            return null;
        }

    }

    private ErrorDescription transformAntlrErrorToNetbeansError(SyntaxError antlrError) {
        String message = antlrError.getMessage();
        int line = antlrError.getLine();
        return ErrorDescriptionFactory.createErrorDescription(Severity.ERROR, message, document, line);
    }

    @Override
    public int getPriority() {
        return 100;
    }

    @Override
    public Class<? extends Scheduler> getSchedulerClass() {
        return Scheduler.EDITOR_SENSITIVE_TASK_SCHEDULER;
    }

    @Override
    public void cancel() {
    }

}
