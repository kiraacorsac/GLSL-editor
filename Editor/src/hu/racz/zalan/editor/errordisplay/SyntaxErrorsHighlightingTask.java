package hu.racz.zalan.editor.errordisplay;

import hu.racz.zalan.editor.antlr.generated.*;
import hu.racz.zalan.editor.core.*;
import static hu.racz.zalan.editor.core.Constants.GLSL;
import hu.racz.zalan.editor.core.scope.*;
import hu.racz.zalan.editor.core.scope.function.*;
import hu.racz.zalan.editor.errordisplay.fix.*;
import java.util.*;
import javax.swing.text.*;
import org.antlr.v4.runtime.*;
import org.netbeans.modules.parsing.spi.*;
import org.netbeans.spi.editor.hints.*;
import org.openide.util.*;

public class SyntaxErrorsHighlightingTask extends ParserResultTask<GlslParser.GlslEditorParserResult> {

    private Document document;
    private final List<ErrorDescription> errors = new ArrayList<>();

    @Override
    public void run(GlslParser.GlslEditorParserResult result, SchedulerEvent event) {
        try {
            document = result.getSnapshot().getSource().getDocument(false);
            errors.clear();
            addErrorsToNetbeansEditor();
        } catch (ParseException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    private void addErrorsToNetbeansEditor() throws ParseException {
        addAntlrErrors();
        addVisitorErrors();
        addVersionMacroError();
        addDuplicatedFunctionDefinitionErrors();
        HintsController.setErrors(document, GLSL, errors);
    }

    private void addVersionMacroError() {
        if (GlslProcessor.getTokens() != null && !GlslProcessor.getTokens().isEmpty()) {
            Token ft = GlslProcessor.getTokens().get(0);
            if (ft.getType() != AntlrGlslLexer.MACRO || !ft.getText().startsWith("#version")) {
                ErrorDescription ed = ErrorDescriptionFactory.createErrorDescription(Severity.WARNING, "The shader should starts with the version macro", document, new ErrorPosition(ft.getStartIndex()), new ErrorPosition(ft.getStopIndex()));
                errors.add(ed);
            }
        }
    }

    private void addDuplicatedFunctionDefinitionErrors() {
        for (FunctionDefinition fd : Scope.getFunctionDefinitions()) {
            if (isFunctionDuplicated(fd)) {
                addDuplicatedFunctionDefinitionError(fd);
            }
        }
    }

    private void addDuplicatedFunctionDefinitionError(FunctionDefinition fd) {
        List<Fix> fixes = new ArrayList<>();
        fixes.add(new RemoveElementFix(document, fd.getStartIndex(), fd.getStopIndex(), "Remove this function"));
        ErrorDescription ed = ErrorDescriptionFactory.createErrorDescription(Severity.ERROR, "'" + fd.getName() + "' function already has a body", fixes, document, new ErrorPosition(fd.getSignatureStartIndex()), new ErrorPosition(fd.getSignatureStopIndex()));
        errors.add(ed);
    }

    private boolean isFunctionDuplicated(FunctionDefinition fd) {
        for (FunctionDefinition def2 : Scope.getFunctionDefinitions()) {
            if (fd != def2 && fd.getFunction().equalsSignature(def2.getFunction()) && fd.getNameStopIndex() > def2.getNameStartIndex()) {
                return true;
            }
        }
        return false;
    }

    private void addVisitorErrors() {
        for (UniqueSyntaxError ed : Scope.getErrors()) {
            errors.add(ed.createError(document));
        }
    }

    private void addAntlrErrors() {
        for (GeneratedSyntaxError error : GlslProcessor.getAutoGeneratedErrors()) {
            ErrorDescription errorDescription = transformAntlrErrorToNetbeansError(error);
            errors.add(errorDescription);
        }
    }

    private ErrorDescription transformAntlrErrorToNetbeansError(GeneratedSyntaxError antlrError) {
        String message = antlrError.getMessage();
        int line = antlrError.getLine();
        return ErrorDescriptionFactory.createErrorDescription(Severity.ERROR, message, document, line);
    }

    @Override
    public int getPriority() {
        return 100;
    }

    @Override
    public Class<? extends Scheduler> getSchedulerClass() {
        return Scheduler.EDITOR_SENSITIVE_TASK_SCHEDULER;
    }

    @Override
    public void cancel() {
    }

}
