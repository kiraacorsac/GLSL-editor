package hu.racz.zalan.editor.errordisplay;

import hu.racz.zalan.editor.antlr.generated.*;
import hu.racz.zalan.editor.core.*;
import hu.racz.zalan.editor.core.scope.*;
import hu.racz.zalan.editor.core.scope.function.*;
import hu.racz.zalan.editor.core.scope.type.*;
import java.util.*;
import javax.swing.text.*;
import org.antlr.v4.runtime.*;
import org.netbeans.modules.parsing.spi.*;
import org.netbeans.spi.editor.hints.*;
import org.openide.util.*;

public class SyntaxErrorsHighlightingTask extends ParserResultTask<GlslParser.GlslEditorParserResult> {

    private Document document;

    @Override
    public void run(GlslParser.GlslEditorParserResult result, SchedulerEvent event) {
        try {
            initialize(result);
            addErrorsToNetbeansEditor();
        } catch (ParseException ex) {
            Exceptions.printStackTrace(ex);
        }
    }

    private void initialize(GlslParser.GlslEditorParserResult result) throws ParseException {
        document = result.getSnapshot().getSource().getDocument(false);
    }

    private void addErrorsToNetbeansEditor() throws ParseException {
        List<SyntaxError> antlrGeneratedErrors = GlslProcessor.getAutoGeneratedErrors();
        List<ErrorDescription> errors = new ArrayList<>();
        for (SyntaxError error : antlrGeneratedErrors) {
            ErrorDescription errorDescription = transformAntlrErrorToNetbeansError(error);
            errors.add(errorDescription);
        }

        Scope rootScope = GlslProcessor.getRootScope();

        Token ft = GlslProcessor.getTokens().get(0);
        if (ft.getType() != AntlrGlslLexer.MACRO || !ft.getText().startsWith("#version")) {
            ErrorDescription ed = ErrorDescriptionFactory.createErrorDescription(Severity.WARNING, "The shader should starts with the version macro", document, new ErrorPosition(ft.getStartIndex()), new ErrorPosition(ft.getStopIndex()));
            errors.add(ed);
        }

        for (int i = 0; i < rootScope.getFunctionDefinitionCount(); i++) {
            FunctionDefinition def = rootScope.getFunctionDefinition(i);
            boolean valid = false;
            boolean valid2 = true;
            if (def.getName().equals("main") && def.getParameterCount() == 0 && def.getReturnType().isVoid()) {
                valid = true;
            }
            for (int j = 0; j < rootScope.getFunctionPrototypeCount(); j++) {
                FunctionPrototype prot = rootScope.getFunctionPrototype(j);
                if (prot.isPrototypeOf(def) && prot.getNameStopIndex() < def.getNameStartIndex()) {
                    valid = true;
                }
            }
            for (int j = 0; j < rootScope.getFunctionDefinitionCount(); j++) {
                FunctionDefinition def2 = rootScope.getFunctionDefinition(j);
                if (def != def2 && def.equalsSignature(def2) && def.getNameStopIndex() > def2.getNameStartIndex()) {
                    valid2 = false;
                }
            }
            if (!valid) {
                List<Fix> fixes = new ArrayList<>();
                fixes.add(new CreateFunctionPrototype(def));
                //TODO: nem kötelező amúgy a prototípus
                ErrorDescription ed = ErrorDescriptionFactory.createErrorDescription(Severity.WARNING, def.getName() + " function's prototype not exists", fixes, document, new ErrorPosition(def.getSignatureStartIndex()), new ErrorPosition(def.getSignatureStopIndex()));
                errors.add(ed);
            }
            if (!valid2) {
                List<Fix> fixes = new ArrayList<>();
                fixes.add(new MyFix(def.getStartIndex(), def.getStopIndex()));
                ErrorDescription ed = ErrorDescriptionFactory.createErrorDescription(Severity.ERROR, "'" + def.getName() + "' function already has a body", fixes, document, new ErrorPosition(def.getSignatureStartIndex()), new ErrorPosition(def.getSignatureStopIndex()));
                errors.add(ed);
            }
        }

        for (ErrorDescription ed : Scope.getErrors()) {
            errors.add(ed);
        }

        HintsController.setErrors(document, "GLSL", errors);
    }

    public class CreateFunctionPrototype implements Fix {

        private final FunctionDefinition functionDefinition;

        public CreateFunctionPrototype(FunctionDefinition func) {
            this.functionDefinition = func;
        }

        @Override
        public String getText() {
            return "Create prototype";
        }

        @Override
        public ChangeInfo implement() throws Exception {
            document.insertString(functionDefinition.getStartIndex(), functionDefinition + ";\n\n", null);
            return null;
        }

    }

    public class MyFix implements Fix {

        private final int start;
        private final int end;

        public MyFix(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        public String getText() {
            return "Remove this function";
        }

        @Override
        public ChangeInfo implement() throws Exception {
            document.remove(start, end - start);
            return null;
        }

    }

    private ErrorDescription transformAntlrErrorToNetbeansError(SyntaxError antlrError) {
        String message = antlrError.getMessage();
        int line = antlrError.getLine();
        return ErrorDescriptionFactory.createErrorDescription(Severity.ERROR, message, document, line);
    }

    @Override
    public int getPriority() {
        return 100;
    }

    @Override
    public Class<? extends Scheduler> getSchedulerClass() {
        return Scheduler.EDITOR_SENSITIVE_TASK_SCHEDULER;
    }

    @Override
    public void cancel() {
    }

}
